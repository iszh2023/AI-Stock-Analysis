
// Animation made at https://www.khanacademy.org/partner-content/pixar/pixar-rigging/intro-to-rigging/a/animate-a-rigged-character

frameRate(24);
var shapes = [{
  name: "base",
  origin: [130, 350],
  fill: -1972501,
  stroke: -3618616,
  vertices: [[66, 350], [194, 350], [190, 335], [138, 335], [138, 320], [122, 320], [122, 335], [70, 335]]
}, {
  name: "arm1",
  origin: [130, 328],
  fill: -1972501,
  stroke: -3618616,
  vertices: [[130, 337], [140, 327], [60, 247], [50, 257]]
}, {
  name: "arm2",
  origin: [60, 257],
  fill: -1972501,
  stroke: -3618616,
  vertices: [[50, 257], [60, 267], [140, 187], [130, 177]]
}, {
  name: "head",
  origin: [127, 194],
  fill: -1972501,
  stroke: -3618616,
  vertices: [[150, 197], [130, 177], [110, 197], [130, 217], [150, 277], [210, 217]]
}];
var connections = ["base->arm1", "arm1->arm2->head"];
var deformers = ["rotate->base", "rotate->arm1", "rotate->arm2", "rotate->head", "translateX->base", "translateY->base", "scale->head"];
var n = 47;

var avars = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, -1.8, -2.25, -1.69, -0.68, 1.22, 3.2, 5.56, 8.24, 11.23, 13.63, 17.04, 19.72, 23.43, 26.3, 30.21, 33.18, 36.16, 40.14, 43.1, 46.02, 48.89, 52.6, 55.28, 57.86, 60.31, 63.36, 65.46, 67.38, 69.65, 71.1, 72.32, 73.56, 74.19, 74.57, 74.51, 73.92, 72.72, 70.88, 68.35, 65.1, 59.96, 53.56, 45.82, 34.66, 21.34, 0], [0, -0.39, -1.51, -3.3, -5.69, -7.99, -10.6, -13.49, -16.63, -19.97, -23.49, -26.23, -29.99, -33.83, -36.74, -40.65, -43.58, -47.46, -50.33, -54.07, -56.8, -59.45, -62.83, -65.23, -68.23, -70.3, -72.22, -74.49, -75.97, -77.62, -78.59, -79.5, -79.89, -79.97, -79.53, -78.54, -77.41, -75.37, -72.68, -68.35, -64.09, -59.07, -51.68, -43, -30.77, -19.01, 0], [0, -0.25, -0.76, -1.84, -3.33, -4.71, -6.86, -8.69, -11.38, -13.58, -16.72, -19.21, -22.68, -26.29, -29.07, -32.86, -36.68, -39.56, -43.39, -47.17, -51.77, -55.31, -58.68, -62.63, -66.19, -69.88, -72.81, -71.66, -74, -77.81, -81.62, -86.79, -90.86, -94.5, -97.4, -99.22, -99.63, -98.82, -95.99, -92.36, -85.27, -78.08, -65.73, -54.21, -40.61, -19, 0], [-489.8, -426.89, -369.02, -315.95, -267.45, -223.29, -192.88, -155.75, -122.32, -99.53, -72.02, -53.41, -31.11, -16.13, 1.68, 13.54, 27.57, 39.75, 47.81, 57.32, 65.62, 72.94, 81.08, 87.06, 94.25, 103.07, 112.81, 139.7, 154.23, 162.26, 222.74, 198.08, 204.59, 234.85, 274.07, 312.55, 345.18, 377.94, 409.47, 431.47, 451.4, 468.69, 478.46, 490.04, 495.46, 498.84, 500], [-200, -161.76, -123.52, -99.57, -75.62, -60.2, -38.15, 1.23, 80.68, 107.67, 134.65, 167.32, 200, 155.08, 110.17, 68.92, 27.67, 15.05, 4.7, -21.22, -92.29, -105.44, -118.6, -138.12, -157.64, -84.9, -38.93, 0.42, 27.91, 65.02, 106.21, 143.29, 159.18, 164.05, 200, 177.06, 157.13, 123.49, 93.43, 32.4, -31.92, -45.37, -93.53, -131.97, -143.46, -139.87, -126.53], [1, 0.99, 0.98, 0.98, 0.99, 1, 1.01, 1.03, 1.04, 1.06, 1.09, 1.11, 1.14, 1.15, 1.18, 1.2, 1.23, 1.25, 1.28, 1.3, 1.32, 1.35, 1.37, 1.39, 1.41, 1.42, 1.45, 1.46, 1.48, 1.49, 1.5, 1.51, 1.51, 1.52, 1.52, 1.51, 1.5, 1.5, 1.48, 1.45, 1.43, 1.39, 1.34, 1.28, 1.21, 1.11, 1]];
var deformerData = {
  translateX: {
    min: -500,
    max: 500,
    transform: function (coord, origin, value) {
            coord.x += value;
        }
  },
  translateY: {
    min: -200,
    max: 200,
    transform: function (coord, origin, value) {
            coord.y -= value;
        }
  },
  scale: {
    min: 0.2,
    max: 3,
    value: 1,
    transform: function (coord, origin, value) {
            coord.x = (coord.x - origin.x) * value + origin.x;
            coord.y = (coord.y - origin.y) * value + origin.y;
        }
  },
  rotate: {
    min: -180,
    max: 180,
    transform: function (coord, origin, value) {
            var cosAngle = cos(value);
            var sinAngle = sin(value);
            var x = coord.x - origin.x;
            var y = coord.y - origin.y;
            coord.x = origin.x + x * cosAngle - y * sinAngle;
            coord.y = origin.y + x * sinAngle + y * cosAngle;
        }
  }
};

var drawBackground = function (x, y, w, h) {
    noStroke();
    fill(82, 115, 173);
    rect(x, y, w, h - 75);
    fill(184, 134, 40);
    rect(x, y + h - 75, w, 75);
};

var drawCircle = function() {
    var r = dist(this.finalCoords[0].x, this.finalCoords[0].y, this.finalCoords[1].x, this.finalCoords[1].y);
    ellipse(this.finalCoords[0].x, this.finalCoords[0].y, r, r);
};
var Shape = function(data, name) {
    if (data.origin) {
        this.originalOrigin = new PVector(data.origin[0], data
.origin[1]);
    }
    if (data.radius && data.center) {
        var center = data.center;
        data.vertices = [center, [center[0] + data.radius,
center[1]]];
        data.drawShape = drawCircle;
    }
    this.originalCoords = data.vertices || [];
    this.fillColor = data.fill;
    this.strokeColor = data.stroke;
    this.strokeWeight = data.strokeWeight || 1;
    this.subdivide = constrain(data.subdivide | 0, 0, 4);
    if (data.drawShape) {
        this.drawShape = data.drawShape.bind(this);
    }
    this.dependentShapes = [];
    this.resetCoords();
    this.updateCurvePoints();
};
Shape.prototype.resetCoords = function() {
    this.finalCoords = this.originalCoords.map(function(coord){
        return new PVector(coord[0], coord[1]);
    });
    if (this.originalOrigin) {
        this.origin = this.originalOrigin.get();
    }
};
Shape.prototype.transform = function(transform, origin, value) {
    for (var i = 0; i < this.finalCoords.length; i++) {
        transform(this.finalCoords[i], origin, value);
    }
    this.updateCurvePoints();
    this.dependentShapes.forEach(function(shape) {
        transform(shape.origin, origin, value);
        shape.transform(transform, origin, value);
    });
};
Shape.prototype.draw = function() {
    if (this.fillColor || this.drawShape) {
        noStroke();
        fill(0, 0, 0, 50);
        pushMatrix();
        translate(2, 3);
        this.drawShape(true);
        popMatrix();
        fill(this.fillColor);
    } else {
        noFill();
    }
    if (this.strokeColor) {
        strokeWeight(this.strokeWeight);
        stroke(this.strokeColor);
    } else {
        noStroke();
    }
    this.drawShape();
};
Shape.prototype.drawShape = function() {
    beginShape();
    this.curvePoints.forEach(function(p) { vertex(p.x, p.y); });
    endShape(CLOSE);
};
Shape.prototype.updateCurvePoints = function() {
    if (!this.subdivide) {
        this.curvePoints = this.finalCoords;
    } else {
        var q = pow(2, this.subdivide);
        var q2 = q * q;
        var n = this.finalCoords.length;
        var p1, p2, p3, a, b, c, s, t, x, y;
        this.curvePoints = [];
        for (var i = 0; i < n; i++) {
            p1 = this.finalCoords[(i + n - 1) % n];
            p2 = this.finalCoords[i];
            p3 = this.finalCoords[(i + 1) % n];
            for (t = 0; t < q; t++) {
                s = q - t - 1;
                a = (s * s + s) >> 1;
                c = (t * t + t) >> 1;
                b = q2 - a - c;
                x = (p1.x * a + p2.x * b + p3.x * c) / q2;
                y = (p1.y * a + p2.y * b + p3.y * c) / q2;
                this.curvePoints.push({x: x, y: y});
            }
        }
    }
};
var Model = function(shapes, connections, deformers) {
    this.shapes = {};
    this.deformers = [];
    this.id = 0;
    if (shapes) {
        for (var i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            if (!shape) { continue; }
            var name = shape.name || 'shape' + this.id++;
            this.shapes[name] = new Shape(shape, name);
        }
    }
    var splitRE = new RegExp('\\s*->\\s*');
    if (connections) {
        for (var i = 0; i < connections.length; i++) {
            var shapes = connections[i].split(splitRE);
            for (var j = 0; j < shapes.length - 1; j++) {
                this.shapes[shapes[j]].dependentShapes.push(this.shapes[shapes[j + 1]]);
            }
        }
    }
    if (deformers) {
        for (var i = 0; i < deformers.length; i++) {
            var d = deformers[i].split(splitRE);
            this.deformers.push([this.shapes[d[1]], deformerData[d[0]].transform, avars[i]]);
        }
    }
};


var model = new Model(shapes, connections, deformers);
var t = 0;

draw = function() {
	t = (t + 1) % n;
	for (var shape in model.shapes) {model.shapes[shape].resetCoords();}
	model.deformers.forEach(function(d){d[0].transform(d[1], d[0].origin, d[2][t]);});
	background(0);
	drawBackground(0, 50, 400, 300);
	pushMatrix();
	translate(0, 50);
	scale(0.75, 0.75);
	for (var shape in model.shapes) { model.shapes[shape].draw(); }
	popMatrix();
};
